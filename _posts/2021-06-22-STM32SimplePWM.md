---
title: "STM32: Simple PWM"
date: 2021-06-22 11:40:00 +0800
categories: [STM32, PWM]
tags: [stm32,pwm]     # TAG names should always be lowercase
---

## Purpose
- Ouput simple PWM signal
- No interrupt or other fancy operation

## Setup
- STM32CubeIDE
- STM32CubeMX

## Configuration
### Enable channels to output PWM
Config Timer2 peripheral to operate in PWM mode with CH1 and CH2 output
- MCU config\
![](/Img/STM32SimplePWM/stm32_simple_pwm_mcu.PNG)
- Timer2 config\
![](/Img/STM32SimplePWM/stm32_simple_pwm_pwm_config1.PNG)

### Config PWM 
- PWM frequency\
The PWM frequency is defined by ARR, prescaler value (PSC) and the clock frequency of Timer2.\
For example, if the clock frequency of Timer2 is 4MHz and we want our PWM frequency to be 1kHz.\
Setup: 
**ARR = 999**; 
**PSC = 3**\
![](/Img/STM32SimplePWM/PWM_Frequency_Equation.jpg)
![](/Img/STM32SimplePWM/stm32_simple_pwm_pwm_config2.PNG)
- PWM duty cycle\
The duty cycle presentage is controlled by CCRx register.\
![](/Img/STM32SimplePWM/PWM_Duty_Cycle_Equation.jpg)

## Code
### Init
Generated by STM32CubeMX

```c
/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 3;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}
```

### Change the duty cycle of PWM output by modifying CCRx register and start PWM output by starting channel 1 and 2 of Timer2
According to duty cycle equation, \
If we want 50% PWM, CCRx register should be 999/2.\
If we want 100% PWM, CCRx register should be 999/1.

```c
#define CH1_CHANNEL					(TIM_CHANNEL_1)
#define CH2_CHANNEL					(TIM_CHANNEL_2)
#define CH1_CHANNEL_ID					(0)
#define CH2_CHANNEL_ID					(1)

// Function for configuring duty cycle and starting output PWM
void Timer2PWMStart(uint16_t u16Channel1, uint16_t u16Channel2)
{
    // Modify CCRx register before starting PWM output.
	__HAL_TIM_SET_COMPARE(&htim2, CH1_CHANNEL, u16Channel1);
    __HAL_TIM_SET_COMPARE(&htim2, CH2_CHANNEL, u16Channel2);

    // Start PWM output
    if(htim2.ChannelState[CH1_CHANNEL_ID] != HAL_TIM_CHANNEL_STATE_BUSY)
        HAL_TIM_PWM_Start(&htim2, CH1_CHANNEL);

    if(htim2.ChannelState[CH2_CHANNEL_ID] != HAL_TIM_CHANNEL_STATE_BUSY)
        HAL_TIM_PWM_Start(&htim2, CH2_CHANNEL);
}

```

### Stop PWM output by stopping channel 1 of Timer2
```c
void Timer2PWMStop(void)
{
    // Stop all channel
    HAL_TIM_PWM_Stop(&htim2, CH1_CHANNEL);
    HAL_TIM_PWM_Stop(&htim2, CH2_CHANNEL);
}
```
